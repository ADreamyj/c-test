#define _CRT_SECURE_NO_WARNINGS  1

#include<iostream>

//题目：青蛙跳台阶问题
//一只青蛙一次可以跳上一级台阶，也可以跳上良机台阶。。。也可以跳上n
//级台阶求一个青蛙跳上n级台阶共有多少种跳法？


// 方法1：动态规划
//(1) 状态：
//		子状态：跳上1级，2级，3级。。。。n级台阶的条法数
//		f(n)：还剩下n个台阶的跳法
//(2) 状态递归：
//		第一步有n种跳法：跳一级，跳两级，跳n级
//		跳一级，剩下n - 1级，则剩下的跳法就是f(n - 1)
//		跳两级，剩下n - 2级，则剩下的跳法就是f(n - 2)
//		f(n) = f(n - 1) + f(n - 2) +。。。+f(n - n)
//		f(n) = f(n-1)+f(n-2)+...+f(0) 
//		f(n-1) = f(n-2)+...+f(0)   
//		f(n) = 2*f(n-1) 
//(3) 初始值：
//		f(1) = 1   
//		f(2) = 2*f(1) = 2   
//		f(3) = 2*f(2) = 4   
//		f(4) = 2*f(3) = 8    
//		所以它是一个等比数列   
//		f(n) = 2^(n-1)
//(4) 返回结果：
//		f(N)

int jumpFloor1(int number)
{
	if (number <= 0)
		return 0;
	int result = 1;
	for (int i = 1; i < number; i++)
	{
		result *= 2;
	}
	return result;
}


//方法2：移位操作
//		降低时间复杂度：将其变为O(1)的操作

int jumpFloor2(int number)
{
	if (number <= 0)
		return 0;
	return 1 << (number - 1);
}


//扩展1：上述问题为变态青蛙跳台阶，太疯狂，这只青蛙像是吃了大力丸 
//身上充满了无穷的力量。现在让它变成一个正常的青蛙，限制它一次只
//能跳1阶或者2阶，现在该如何解答 

//扩展2：矩形覆盖     
//我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
//请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法

//像要求出到第n层的台阶，它只能从n - 1和n - 2处到达
//所以就可以把它划分成一个一个的子问题
//f(i) = f(i - 1) + f(i - 2);
//实际上就是Fibonacci数列
//矩形覆盖也是这样的道理



//int main()
//{
//	int number = 5;
//	std::cout << jumpFloor1(5) << std::endl;
//	std::cout << jumpFloor2(5) << std::endl;
//	system("pause");
//	return 0;
//}